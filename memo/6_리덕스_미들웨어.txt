리덕스는 미들웨어로 기능을 추가해줌
3차 고차함수로 미들웨어를 추가한다.

실제 환경에서 로그인, 로그아웃등의 행위는 서버의 
response를 비동기로 받아야 됨
비동기 요청은 3단계로 나뉘니까 action도 똑같이 하자 


thunk

  함수가 지연의 의미를 가진다.
  action을 함수로 호출할 수 있다.
  하나의 액션에서 복수의 dispatch 가능
  기능이 꽤 매우 확장됨
  action이 함수인지 판단해서 후킹

  기능이 간단해서 거의 모든걸 직접 구현해야함
  쓰로틀링등의 기능이 기본적으로 구현되어 있다.

  export const loginAction = (data) => {
    return (dispatch, getState) => {
      dispatch(loginRequestAction())
      axios.post('/api/login')
        .then((res.data)=>{
          dispatch(loginSuccesAction(res.data))
        })
        .catch((err)=>{
          dispatch(loginFailAction(err))    
        })
    }
  } 


saga
  제네레이터 함수 기반
  이펙트라는 개념이 있다.
  패턴이 있어서 제네레이터를 
  완전히 몰라도 사용은 가능

  // all은 배열을 받아 동시에 실행
  // fork는 함수를 실행 (비동기)
  // call도 함수를 실행 (동기)
  // put이 dispatch


yield를 많이 넣으면 중단점이 많아져서
디버깅이 용이


export default function* rootSaga() {
  
}